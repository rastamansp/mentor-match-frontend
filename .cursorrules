# üöÄ Cursor Rules - Gwan Events Frontend

## üìã Vis√£o Geral do Projeto

Este √© um projeto React + TypeScript + Vite que implementa o frontend da plataforma de eventos e venda de ingressos. O projeto segue os princ√≠pios de Clean Architecture, SOLID e melhores pr√°ticas de desenvolvimento frontend.

## üö´ **REGRAS CR√çTICAS - NUNCA VIOLAR**

### ‚ùå **NUNCA desabilitar funcionalidades essenciais:**
- ‚ùå **NUNCA** usar `any` type
- ‚ùå **NUNCA** usar `console.log` (usar logger estruturado ou remover)
- ‚ùå **NUNCA** remover valida√ß√µes de props
- ‚ùå **NUNCA** desabilitar tratamento de erros
- ‚ùå **NUNCA** remover interfaces ou tipos TypeScript
- ‚ùå **NUNCA** fazer opera√ß√µes s√≠ncronas bloqueantes
- ‚ùå **NUNCA** misturar l√≥gica de neg√≥cio com componentes de UI

### ‚úÖ **SEMPRE corrigir problemas de configura√ß√£o:**
- ‚úÖ **SEMPRE** verificar vari√°veis de ambiente
- ‚úÖ **SEMPRE** configurar APIs corretamente
- ‚úÖ **SEMPRE** implementar fallbacks e retry logic
- ‚úÖ **SEMPRE** usar logging estruturado para debug
- ‚úÖ **SEMPRE** seguir princ√≠pios de resili√™ncia

## üèóÔ∏è Arquitetura e Padr√µes

### Clean Architecture (Adaptada para Frontend)
- **Entities**: Tipos e interfaces de dom√≠nio
- **Use Cases**: Custom hooks e l√≥gica de neg√≥cio
- **Interface Adapters**: Services, API clients, Context providers
- **Frameworks & Drivers**: React, Vite, Tailwind, Axios

### SOLID Principles (Adaptados para Frontend)
- **S**: Single Responsibility Principle (componentes com uma responsabilidade)
- **O**: Open/Closed Principle (extens√≠vel via props, fechado para modifica√ß√£o)
- **L**: Liskov Substitution Principle (componentes substitu√≠veis)
- **I**: Interface Segregation Principle (interfaces espec√≠ficas)
- **D**: Dependency Inversion Principle (depender de abstra√ß√µes, n√£o implementa√ß√µes)

### Design Patterns
- **Repository Pattern**: Para acesso a dados via services
- **Factory Pattern**: Para cria√ß√£o de objetos complexos
- **Observer Pattern**: Para gerenciamento de estado (Context API)
- **Command Pattern**: Para a√ß√µes do usu√°rio
- **Provider Pattern**: Para inje√ß√£o de depend√™ncias

## üìÅ Estrutura de Pastas

```
src/
‚îú‚îÄ‚îÄ main.tsx                    # Ponto de entrada
‚îú‚îÄ‚îÄ App.tsx                     # Componente principal
‚îú‚îÄ‚îÄ components/                 # Componentes reutiliz√°veis
‚îÇ   ‚îú‚îÄ‚îÄ Layout.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Header.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Footer.tsx
‚îÇ   ‚îî‚îÄ‚îÄ ProtectedRoute.tsx
‚îú‚îÄ‚îÄ pages/                      # P√°ginas da aplica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ Home.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Events.tsx
‚îÇ   ‚îú‚îÄ‚îÄ EventDetail.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Login.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Register.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.tsx
‚îÇ   ‚îú‚îÄ‚îÄ MyTickets.tsx
‚îÇ   ‚îî‚îÄ‚îÄ AdminDashboard.tsx
‚îú‚îÄ‚îÄ services/                   # Servi√ßos de API
‚îÇ   ‚îî‚îÄ‚îÄ api.ts
‚îú‚îÄ‚îÄ contexts/                   # Contextos React
‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.tsx
‚îú‚îÄ‚îÄ types/                      # Defini√ß√µes TypeScript
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ hooks/                      # Custom hooks (futuro)
‚îú‚îÄ‚îÄ utils/                      # Utilit√°rios (futuro)
‚îî‚îÄ‚îÄ index.css                   # Estilos globais
```

## üîß Padr√µes de C√≥digo

### Nomenclatura
- **Componentes**: PascalCase (ex: `EventCard`, `UserProfile`)
- **Interfaces**: PascalCase com prefixo I (ex: `IEvent`, `IUser`)
- **Fun√ß√µes**: camelCase (ex: `handleSubmit`, `validateForm`)
- **Vari√°veis**: camelCase (ex: `eventList`, `userData`)
- **Constantes**: UPPER_SNAKE_CASE (ex: `API_BASE_URL`, `MAX_EVENTS`)
- **Arquivos**: PascalCase para componentes, camelCase para outros (ex: `EventCard.tsx`, `apiService.ts`)

### Estrutura de Componentes
```typescript
// Sempre usar TypeScript strict
interface IEventCardProps {
  event: IEvent;
  onSelect?: (event: IEvent) => void;
  className?: string;
}

export const EventCard: React.FC<IEventCardProps> = ({ 
  event, 
  onSelect, 
  className 
}) => {
  // Hooks primeiro
  const [isLoading, setIsLoading] = useState(false);
  
  // Handlers
  const handleClick = useCallback(() => {
    onSelect?.(event);
  }, [event, onSelect]);
  
  // Render
  return (
    <div className={className} onClick={handleClick}>
      {/* JSX */}
    </div>
  );
};
```

### Interfaces e Tipos
```typescript
// Sempre definir interfaces para props e dados
export interface IEvent {
  id: string;
  title: string;
  description: string;
  date: Date;
  location: string;
  price: number;
  category: EventCategory;
}

export interface IUser {
  id: string;
  name: string;
  email: string;
  role: UserRole;
  createdAt: Date;
}

// Enums para valores fixos
export enum EventCategory {
  MUSIC = 'MUSIC',
  SPORTS = 'SPORTS',
  CULTURE = 'CULTURE',
  BUSINESS = 'BUSINESS'
}

export enum UserRole {
  USER = 'USER',
  ORGANIZER = 'ORGANIZER',
  ADMIN = 'ADMIN'
}
```

## üéØ Padr√µes de Custom Hooks

### Estrutura de Custom Hook
```typescript
// Sempre usar TypeScript strict
export const useEvents = () => {
  const [events, setEvents] = useState<IEvent[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchEvents = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await apiService.getEvents();
      setEvents(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro desconhecido');
    } finally {
      setLoading(false);
    }
  }, []);
  
  useEffect(() => {
    fetchEvents();
  }, [fetchEvents]);
  
  return {
    events,
    loading,
    error,
    refetch: fetchEvents
  };
};
```

## üîå Padr√µes de Services

### Estrutura de Service
```typescript
// Sempre usar interfaces para abstra√ß√µes
export interface IApiService {
  getEvents(): Promise<IEvent[]>;
  getEvent(id: string): Promise<IEvent>;
  createEvent(event: ICreateEventRequest): Promise<IEvent>;
  updateEvent(id: string, event: IUpdateEventRequest): Promise<IEvent>;
  deleteEvent(id: string): Promise<void>;
}

// Implementa√ß√£o concreta
export class ApiService implements IApiService {
  private baseURL: string;
  
  constructor(baseURL: string = import.meta.env.VITE_API_URL) {
    this.baseURL = baseURL;
  }
  
  async getEvents(): Promise<IEvent[]> {
    try {
      const response = await fetch(`${this.baseURL}/events`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch events: ${error}`);
    }
  }
  
  // Outros m√©todos...
}
```

## üé® Padr√µes de Context

### Estrutura de Context
```typescript
// Sempre definir interface para o contexto
interface IAuthContext {
  user: IUser | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  loading: boolean;
}

// Criar contexto
export const AuthContext = createContext<IAuthContext | undefined>(undefined);

// Provider
export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [user, setUser] = useState<IUser | null>(null);
  const [loading, setLoading] = useState(false);
  
  const login = useCallback(async (email: string, password: string) => {
    try {
      setLoading(true);
      const userData = await apiService.login(email, password);
      setUser(userData);
    } catch (error) {
      throw new Error('Login failed');
    } finally {
      setLoading(false);
    }
  }, []);
  
  const logout = useCallback(() => {
    setUser(null);
  }, []);
  
  const value: IAuthContext = {
    user,
    isAuthenticated: !!user,
    login,
    logout,
    loading
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
```

## üìù Padr√µes de Logging

### Estrutura de Logs
```typescript
// Sempre usar logging estruturado
export const logger = {
  info: (message: string, data?: Record<string, unknown>) => {
    if (import.meta.env.DEV) {
      console.log(`[INFO] ${message}`, data);
    }
  },
  
  error: (message: string, error?: Error, data?: Record<string, unknown>) => {
    if (import.meta.env.DEV) {
      console.error(`[ERROR] ${message}`, { error, data });
    }
  },
  
  warn: (message: string, data?: Record<string, unknown>) => {
    if (import.meta.env.DEV) {
      console.warn(`[WARN] ${message}`, data);
    }
  }
};
```

## üß™ Padr√µes de Testes

### Estrutura de Testes
```typescript
// Testes de componentes
import { render, screen, fireEvent } from '@testing-library/react';
import { EventCard } from './EventCard';

describe('EventCard', () => {
  const mockEvent: IEvent = {
    id: '1',
    title: 'Test Event',
    description: 'Test Description',
    date: new Date(),
    location: 'Test Location',
    price: 100,
    category: EventCategory.MUSIC
  };
  
  it('should render event information', () => {
    render(<EventCard event={mockEvent} />);
    
    expect(screen.getByText('Test Event')).toBeInTheDocument();
    expect(screen.getByText('Test Description')).toBeInTheDocument();
  });
  
  it('should call onSelect when clicked', () => {
    const mockOnSelect = jest.fn();
    render(<EventCard event={mockEvent} onSelect={mockOnSelect} />);
    
    fireEvent.click(screen.getByRole('button'));
    
    expect(mockOnSelect).toHaveBeenCalledWith(mockEvent);
  });
});
```

## üîí Padr√µes de Seguran√ßa

### Valida√ß√£o de Props
```typescript
// Sempre validar props cr√≠ticas
interface ILoginFormProps {
  onSubmit: (email: string, password: string) => Promise<void>;
  loading?: boolean;
}

export const LoginForm: React.FC<ILoginFormProps> = ({ 
  onSubmit, 
  loading = false 
}) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const validateForm = useCallback(() => {
    const newErrors: Record<string, string> = {};
    
    if (!email || !email.includes('@')) {
      newErrors.email = 'Email inv√°lido';
    }
    
    if (!password || password.length < 6) {
      newErrors.password = 'Senha deve ter pelo menos 6 caracteres';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [email, password]);
  
  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    try {
      await onSubmit(email, password);
    } catch (error) {
      logger.error('Login failed', error as Error);
    }
  }, [email, password, onSubmit, validateForm]);
  
  // Render...
};
```

## üìä Padr√µes de Performance

### Otimiza√ß√µes
```typescript
// Usar React.memo para componentes puros
export const EventCard = React.memo<IEventCardProps>(({ event, onSelect }) => {
  // Componente otimizado
});

// Usar useMemo para c√°lculos pesados
const expensiveValue = useMemo(() => {
  return events.filter(event => event.category === selectedCategory);
}, [events, selectedCategory]);

// Usar useCallback para fun√ß√µes est√°veis
const handleEventSelect = useCallback((event: IEvent) => {
  setSelectedEvent(event);
}, []);
```

## üö´ O que N√ÉO fazer

- ‚ùå N√£o usar `any` type
- ‚ùå N√£o fazer `console.log` (usar logger estruturado)
- ‚ùå N√£o deixar props sem valida√ß√£o
- ‚ùå N√£o misturar l√≥gica de neg√≥cio com UI
- ‚ùå N√£o usar `var` (sempre `const` ou `let`)
- ‚ùå N√£o fazer opera√ß√µes s√≠ncronas bloqueantes
- ‚ùå N√£o esquecer de tratar erros
- ‚ùå N√£o usar vari√°veis globais
- ‚ùå N√£o criar componentes muito grandes (>200 linhas)
- ‚ùå N√£o usar `useEffect` sem depend√™ncias corretas

## ‚úÖ O que SEMPRE fazer

- ‚úÖ Usar TypeScript strict mode
- ‚úÖ Definir interfaces para todas as props
- ‚úÖ Usar hooks apropriadamente
- ‚úÖ Validar entrada de dados
- ‚úÖ Tratar erros adequadamente
- ‚úÖ Usar logs estruturados
- ‚úÖ Seguir princ√≠pios SOLID
- ‚úÖ Implementar Clean Architecture
- ‚úÖ Usar React.memo quando apropriado
- ‚úÖ Usar useCallback e useMemo quando necess√°rio
- ‚úÖ Separar l√≥gica de neg√≥cio de UI
- ‚úÖ Criar custom hooks para l√≥gica reutiliz√°vel

## üîÑ Fluxo de Desenvolvimento

1. **Definir Interface** - Como o componente se comunica
2. **Criar Componente** - Implementa√ß√£o seguindo os padr√µes
3. **Adicionar Hooks** - L√≥gica de estado e efeitos
4. **Validar Props** - Verificar entrada de dados
5. **Tratar Erros** - Implementar tratamento adequado
6. **Testar** - Componente funciona corretamente
7. **Otimizar** - Performance quando necess√°rio

---

**Lembre-se**: Este arquivo define os padr√µes do projeto frontend. Sempre consulte antes de implementar novas funcionalidades para garantir consist√™ncia e qualidade do c√≥digo. **NUNCA desabilite funcionalidades essenciais - sempre corrija os problemas de configura√ß√£o!**